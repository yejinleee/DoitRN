# 함수 컴포넌트와 리액트 훅

[04-1 리액트 훅 맛보기](#04-1-리액트-훅-맛보기)

[04-2 useMemo와 useCallback 훅 이해하기](#04-2-usememo와-usecallback-훅-이해하기)

[04-3 useState 훅 이해하기](#04-3-usestate-훅-이해하기)

[04-4 useEffect와 useLayoutEffect 훅 이해하기](#04-4-useeffect와-uselayouteffect-훅-이해하기)

[04-5 커스텀 훅 이해하기](#04-5-커스텀-훅-이해하기)

---

`npx react-native init {생성할 프로젝트명} --template react-native-template-typescript`

# 04-1 리액트 훅 맛보기

- 컴포넌트 데이터 관리
  - [useMemo](#usememo-훅)
  - [useCallback](#usecallback-훅)
  - [useState](#usestate-훅)
  - useReducer
- 컴포넌트 생명주기 대응
  - [useEffect](#uselayouteffect와-useeffect-생명주기-훅)
  - [useLayourEffect](#uselayouteffect와-useeffect-생명주기-훅)
- 컴포넌트 간의 정보 공유
  - useContext
- 컴포넌트 메서드 호출
  - useRef
  - useImperativeHandle

#### 리액트 훅 사용시 주의사항

- 같은 리액트 훅을 여러번 호출할 수 있다.
- 함수 컴포넌트 몸통에서만 호출해야한다.

```
export default function App(){
    // 이안에서만 호출할것.
    const [x, setX] = useState(0);
    {
        //이렇게 몸통 안 복합 실행문 {}안에선 호출 하면 안된다!
        const [no, setNo]= useState(false);
    }
    if (true){
        //또한 이런 if문인 {}안에서 사용하므로 안된다!
        const [no2, setNo2] = useState(false);
        //for 문도 마찬가지다.
    }
    useEffect( ()=>{ //이 useEffect훅은 몸통안이므로 가능
        //하지만 이 안은 또 다시 {} 안이므로 안된다!
        const [no3, setNo3] = useState(false);
    })
}
```

- 훅 함수에 비동기함수(async)를 콜백함수로 지정할 수 없다.

```
export default function App(){
    useEffect( async()=>{  //이렇게 async키워드가 붙은 비동기
        await Promise.resolve(1);
    })
}
```

### import { } from 'react'

리액트 훅은 리액트 네이티브가 아닌 리액트가 제공.

```
import React, {
  useEffect,
  useState,
  useMemo,
  useCallbak,
  useState,
  useEffect, useLayourEffect} from 'react';
```

### useEffect 훅

> useEffect(콜백\_함수, deps) <br/>
> 콜백\_함수 = () =>{}

컴포넌트가 처음 렌더링될 때 한번만 호출할 때 적합

# 04-2 useMemo와 useCallback 훅 이해하기

### 수평 방향으로 ScrollView 스크롤

스크롤 기능이 있는 컴포넌트가 부모/자식 관계에 있으면 스크롤 방향을 각기 다르게 해줘야 함.

FlatList : 수직 방향으로 스크롤 됨.<br/>
-> 이 컴포넌트의 부모인 App.tsx의 ScrollView는 스크롤을 수평 방야으로 설정해야 함.

```
<ScrollView
  horizontal={true} //default가 true라 horizontal 만 써도 됨
  `contentContainerStyle` = {스크롤할 컴포넌트의 갯수}
/>
```

### 전역변수와 캐시

데이터 선언을 컴포넌트 안쪽에 두면 컴포넌트를 렌더링할 때 마다 계속 새로 생긴다. (지역변수니까)

지역 변수도 전역 변수처럼 사용하고 싶다면 ? ? 훅 사용 !!

- FlatList 코어 컴포넌트

  'View'자가 들어간 코어 컴포넌트와 달리 부모의 width 속성을 상속받지 않는다. <br/>
  부모의 alignItems 속성 영향을 안받으려면 width:'100%' 설정을 해주어야 한다.

createOrUse 함수와 Cache.tsx파일의 people 선언 방법을 훅으로 간결히 해결할 수 있다 ! useMemo훅으로 !!

### 의존성이란?

리액트 프레임워크 내부에서 관리하는 캐시가 어떤 상황이 일어나서 갱신해야 할 시기

useMemo, useCallback, useEffeect 훅은 deps(의존성)목록에 있는 deps에 변화가 생길 때마다 콜백 함수를 자동으로 호출하여 deps을 반영한다.

### useMemo 훅

처음 렌더링할 때 한번만 생성하는 것이 효율적인 데이터에 사용

> const 캐시된\_데이터 = useMemo(콜백\_함수, [deps 목록]) <br />
> 콜백\_함수 = () => 원본\_데이터<br/>
> 제네릭 함수로 표현하면, <br/>
> useMemo<T>(()=> T, [deps목록]) : T

useMemo(데이터)가 아니라 useMemo(()=> 데이터) 이다 !!!

### useCallback 훅

> const 캐시된\_콜백\_함수 = useCallback(원본\_콜백\_함수, deps목록)

**콜백 함수**를 캐시한다. < - > useMemo는 데이터나 함수 호출의 결과값을 캐시한다.

<!-- 교재 p222 예시에 보기에 useMemo( () => fibonacci 였는데 이게 데이터나 결과값 캐시인가 ? ? ? 이후에 memoizedFibonacci(index)로 호출하는데 ? '콜백함수' 캐시한다는게 다른건가 ) -->

컴포넌트가 재렌더링 될 때마다 같은 함수를 계속 다시 만드는 비효율을 막을 수 있다.

//사용예시

```
const avatarPressed = useCallback(()=> Alert.alert('Avatar Pressed'), [])
//매개변수가 있는 콜백함수라면
const textChange = useCallback((text:string) => console.log(text), [])
```

<!-- 고차함수에도  -->

# 04-3 useState 훅 이해하기

`npm i react-native-vector-icons react-native-paper color faker@5.5.3 moment moment-with-locales-es6` <br/>
`npm i -D @types/react-native-vector-icons @types/color @types/faker@5.5.3`<br/>
`npx react-native link react-native-vector-icons`

### useState 훅

> const[현재_값, set_함수] = useState(초기\_값); <br/>
> set\_함수 = (새로운\_값) : void

set\_함수가 초기값으로 값을 변경함과 동시에 컴포넌트를 재렌더링된다.

### 상태를 사용하는 컴포넌트 구현

setState를 이용하여

```
const commentPressed = () => { setComment(comment +1)}
```

이렇게 구현하면 컴포넌트를 재렌더링 할때마다 이 함수를 반복 생성하게 된다. 비효율적..
이 때 useCallback 훅을 적용하는 것이 효율적이다!

```
const commentPressed = useCallback(()=> {setComment(comment + 1)}, [comment]) //deps를 comment라고 주어 comment의 변경 된 값이 콜백 함수에 반영된다.
```

더 나은 방법은

```
const commentPressed = useCallback(()=> {setComment(comment => comment + 1)}, [])
// setComment 함수내부에서 현재 comment 값을 넘겨주므로 deps에 추가하지 않아도 된다!!
```

#### 객체를 상태로 했을 때의 구현 방법

위에서 number타입으로 각각 선언했다. <br/>
객체를 대상으로도 useState를 사용할 수도 있다!

```
const commentPressd = useCallback(() => setPerson(person => (
    {...person, counts : {...person.counts, comment: person.counts.comment +1}}
),[])
```

    person객체를 깊은 복사하여 완전히 새로운 객체를 만들어 상태를 변경하고 반환하기 때문에 이 변경을 인지하여 재렌더링 한다.

여기서 **깊은 복사**란 ? ?

- 얕은 복사

```
let p = {comment: 1};
let newp = p
newp.comment = 10
const equal = p === newp // true
```

    새로운 변수에 복사해오는 것 같아 보여도 사실은 같은 객체를 가리킨다.
    n과 np 둘다의 comment값을 10으로 바꾸는 것.

- 깊은 복사 : ...연산자

```
let person = { comment : 1}
let newPerson = {...person}
```

    새로운 newPerson은 새로운 객체에 person의 모든 속성값을 복사한 것.
    서로 영향 주지 않는다. 완전히 다른 객체.

#### 자식 컴포넌트에서 부모 컴포넌트의 상태 변경하기

> 자식에게 상태(state)와 상태변경함수(set\_함수)만 넘겨주면 된다!

- useState 타입 주의!<br/>
  상태의 타입을 S 라 하면, set\_함수의 타입은 Dispatch<SetStateAction<S\>>이다.

  // .../PersonUsingPassingState.tsx에서 <br/>
  현재 부모 상태 타입이 D.IPerson이다. (PersonProps에서 정의)<br/>
  그러므로 setPerson의 타입은 Dispatch<SetStateAction<D.IPerson>>이다.

```
//부모 : PersonUsingObjectState.tsx
//자식 : PersonIcon.tsx
//전달 props : person, setPerson
//
// 자식에서
export type PersonIconsProps = {
    person: D.IPerson
    setPerson: Dispatch<SetStateAction<D.IPerson>>
}
```

#### 배열을 상태로 했을 때의 구현 방법

```
const people = useMemo(() => D.makeArray(10).map(D.createRandomPerson),[]);
// 이렇게 useMemo를 사용하여 데이터 만드는 방식을
// useState를 이용하여 배열로 만들 수 있다.

const [people, setPeople] = useState<D.IPerson[]>([])
```

자식컴포넌트에 setPeople을 넘겨주며 people의 값을 바꾼다면<br/>
부모에서 people을 사용할 때 useMemo에 deps로 people.length를 주어 변화를 감지해야 한다.

### 배열 데이터를 컴포넌트의 상태로 만들 때 주의할 점

- 배열 깊은 복사

```
let people = []
let newPeople = [...people]
```

# 04-4 useEffect와 useLayoutEffect 훅 이해하기

### useLayoutEffect와 useEffect 생명주기 훅

> useEffect(콜백\_함수, deps목록) <br/>
> useLayoutEffect(콜백\_함수, deps목록) <br/>
> 콜백\_함수 = () => { }
>
> > 이 콜백함수는 { } 안에서 return 반환\_함수를 할 수 있는데, 이 반환\_함수는 컴포넌트를 **언마운트** 할 때 단 한번 실행한다.

#### 리액트 네이티브 컴포넌트의 onLayour 이벤트 속성

##### + 모든 RN컴포넌트 onLayout 이벤트 속성을 제공한다.

```
import type {LayoutChangeEvent} from 'react-native'
```

#### useLayoutEffect와 useEffect 훅의 호출 순서

- 마운트 때

컴포넌트 렌더링 시장 -> useLayourEffect 호출 -> (화면 나타남) -> useEffect 호출 -> onLayout 이벤트 발생

- 언마운트 때

컴포넌트 언마운트 시작 -> useEffect 반환 함수 호출 -> useLayourEffect 반환 함수 호출 -> 컴포넌트 파괴

#### ActivityIndicator 코어 컴포넌트

🔜🔜🔜🔜🔜🔜🔜🔜🔜🔜🔜🔜🔜🔜🔜

### fetch API 사용하기

#### Promise 객체의 then-체인

then 메서드를 연달아 호출할 수 있다.

#### useEffect 훅에서 fetch API 호출하기

# 04-5 커스텀 훅 이해하기

### BottomNavigation 컴포넌트 사용하기

react-native-paper 패키지가 제공

```
import {BottomNavigation} from 'react-native-paper'
```

- BottomNavigation의 3개 속성

```
<BottomNavigation
  navigationState = {{index, routes}}
  onIndexChange = {setIndex}
/>
```

<!--
책에 있는 기본 코드 베이스
const [routes] = useState( [ { key:'home', title: 'Home', icon:'home'} , { } , ... ])
이렇게 routes에 key, title, icon키가 있는 객체를 추가
const renderScene
에서 키 : 해당컴포넌트로
이동될 컴포넌트 설정
 -->

### 커스텀 훅이란?

- use~로 시작해야한다.
- 몸통에서 다른 커스텀 훅을 호출할 수 있다.
- 반환값 타입을 꼭! 명시해야 한다.

#### Promise 객체와 async/await 구문의 이해

- Promise <br/>
  오류가 발생하는 resolve값 or reject된 오류(Error타입) 둘 중 하나 반드시 발생시킴.
  <br/>Promise<T>는 resolve된 값의 타입을 타입 변수 T로 하는 제네릭 타입이다. 즉, T타입을 resolve 한다는 것.

- async/await<br/>
  await 연산자를 사용하려면 이 연산자를 호출하는 함수 앞에 반드시 async라는 함수 수정자 붙일 것.<br/>

```
const asyncFn = async () => {
  const value1 = await Promise.resole(1) //1
}
```

<!--
.
.
.
.
.
.. -->

# 추가 공부

### 제네릭

```
function myFunc<T>(arg:T):T{
    return arg;
}
```

함수명<타입변수> (인자:인자타입) : 반환타입{ }

< >안에 타입을 적어 둔 것이고 인자(여기서 arg)가 그 타입이라는 뜻
이렇게 함수명 뒤에 < T >를 추가하여 T를 매개변수의 타입 또는 반환 타입으로 설정할 수 있다.

T 대신 다른 문자,문자열이 올 수 있다.

const thatFunc = myFunc<number>(123);
처럼 쓸 수 있다.

< >안에 타입 명시는 생략 가능

const thatFunc = myFunc(123);

#### : any

```
function myFunc(arg:any):any{
    return arg;
}
```

이렇게 any타입으로 지정할 수도 있다.
하지만 반환 타입을 알 수 없다.

반환타입 유추도 쉽고 유지보수 측면에서 좋은 제네릭타입 추천.

참고 - https://developer-talk.tistory.com/195 https://heecheolman.tistory.com/67 https://ahnheejong.gitbook.io/ts-for-jsdev/03-basic-grammar/generics
